Submission 2025-05-22
=====================

Transposition
-------------

This section develops a kernel that performs the identity operation on the elements of an 8x8 column-major matrix A and stores the
result in row-major format in matrix B.

1. Implement a Neon kernel that transposes an 8x8 matrix: B:=Aáµ€
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

File: ``neon_7_1.s``

From the lecture, we already know the 4x4 transpose kernel. Therefore, we have the following idea:

1. Divide the 8x8 matrix A into four 4x4 sub-matrices
2. Transpose each 4x4 sub-matrix
3. Save T(A) and T(D) sub-matrix to matrix B
4. Swap B and C: Save T(B) to bottom-left sub-matrix of B and T(C) to top-right sub-matrix of B

.. image:: ../_static/images/report_25_04_22/trans_8_8.png
    :align: left

.. code-block:: asm
    :linenos:

    ...
    /*
    * Part 1:
    * Load 4x4 sub-matrix A.
    * Transpose 4x4 block.
    * Store 4x4 block of A into B.
    */
    // Load
    ldr q0, [x4]
    add x4, x4, x2
    ldr q1, [x4]
    add x4, x4, x2
    ldr q2, [x4]
    add x4, x4, x2
    ldr q3, [x4]

    // Transpose
    trn1 v4.4s, v0.4s, v1.4s
    trn2 v5.4s, v0.4s, v1.4s
    trn1 v6.4s, v2.4s, v3.4s
    trn2 v7.4s, v2.4s, v3.4s

    zip1  v8.2d, v4.2d, v6.2d
    zip1  v9.2d, v5.2d, v7.2d
    zip2 v10.2d, v4.2d, v6.2d
    zip2 v11.2d, v5.2d, v7.2d

    // Store
    str q8, [x5]
    add x5, x5, x3
    str q9, [x5]
    add x5, x5, x3
    str q10, [x5]
    add x5, x5, x3
    str q11, [x5]

    /*
    * Part 2:
    * Load 4x4 sub-matrix B and C.
    * Transpose both 4x4 blocks.
    * Store both 4x4 blocks of C and B into B.
    */
    // Load right-top
    mov x4, x0       // A
    add x4, x4, #128 // Offset to top-left corner of right half of A (32th element)
    ...

    // Transpose right-top
    ...

    // Load left-bottom
    mov x4, x0      // A
    add x4, x4, #16 // Offset to next 4 elements of column in A (4th element)
    ...

    // Transpose left-bottom
    ...

    // Store after transpose to avoid conflicts when input matrix A = B
    // Store B to C (right-top of A to left-bottom of B)
    mov x5, x1
    add x5, x5, #16
    ...

    // Store C to B (left-bottom of A to right-top of B)
    mov x5, x1
    add x5, x5, #128
    ...

    /*
    * Part 3:
    * Load 4x4 sub-matrix D.
    * Transpose 4x4 block.
    * Store 4x4 block of A into B.
    */
    // Load
    mov x4, x0       // A
    add x4, x4, #144 // 128 + 16 -> left-top corner of right-bottom 4x4 sub-matrix of A
    ...

    // Transpose
    ...

    // Store
    mov x5, x1       // A
    add x5, x5, #144 // 128 + 16 -> left-top corner of right-bottom 4x4 sub-matrix of B
    ...

2. Test and optimize
^^^^^^^^^^^^^^^^^^^^

.. code-block::
    :emphasize-lines: 4

    --------------------------------------------------------------------------------------------------------------
    Benchmark                                                         Time             CPU   Iterations       Byte
    --------------------------------------------------------------------------------------------------------------
    Trans8x8Fixture/BT_tran_8_8/min_warmup_time:1.000_mean         5.08 ns         5.07 ns           10 50.5296G/s
    Trans8x8Fixture/BT_tran_8_8/min_warmup_time:1.000_median       5.08 ns         5.07 ns           10 50.5329G/s
    Trans8x8Fixture/BT_tran_8_8/min_warmup_time:1.000_stddev      0.038 ns        0.038 ns           10  375.02M/s
    Trans8x8Fixture/BT_tran_8_8/min_warmup_time:1.000_cv           0.75 %          0.74 %            10      0.74%


- **tran_8_8** kernel: :math:`50.5` GiB/s


Unary Primitives
----------------