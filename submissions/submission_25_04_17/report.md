Submission 25/04/17
===================

Hello Assembly
--------------

1) Use the GCC and Clang compilers to compile the function and generate assembly code.

- gcc: ``gcc -S hello_assembly.c -o hello_assembly.s``
- clang: ``clang -S hello_assembly.c -o hello_assembly_clang.s``

2) In the generated assembly code generated by the two compilers:

  **gcc**
  * Locate the string "Hello Assembly Language!".
    - line 7
  * Identify the instructions that the compilers insert to conform to the procedure call standard.
    - ``stp	x29, x30, [sp, -16]!``
    - ``mov	x29, sp``
    - ``ldp x29, x30, [sp], 16``
  * Identify the function call to libc that prints the string.
    - ``bl	puts`` [branch link](https://developer.arm.com/documentation/dui0379/e/arm-and-thumb-instructions/bl) [puts](https://pubs.opengroup.org/onlinepubs/009695399/functions/puts.html)
  ```
    .arch armv8-a
    .file	"hello_assembly.c"
    .text
    .section	.rodata
    .align	3
  .LC0:
    .string	"Hello Assembly Language!"
    .text
    .align	2
    .global	hello_assembly
    .type	hello_assembly, %function
  hello_assembly:
  .LFB0:
    .cfi_startproc
    stp	x29, x30, [sp, -16]!
    .cfi_def_cfa_offset 16
    .cfi_offset 29, -16
    .cfi_offset 30, -8
    mov	x29, sp
    adrp	x0, .LC0
    add	x0, x0, :lo12:.LC0
    bl	puts
    nop
    ldp	x29, x30, [sp], 16
    .cfi_restore 30
    .cfi_restore 29
    .cfi_def_cfa_offset 0
    ret
    .cfi_endproc
  .LFE0:
    .size	hello_assembly, .-hello_assembly
    .ident	"GCC: (GNU) 14.2.1 20250110 (Red Hat 14.2.1-7)"
    .section	.note.GNU-stack,"",@progbits
  ```
  **clang**
  * Locate the string "Hello Assembly Language!".
    - line 31
  * Identify the instructions that the compilers insert to conform to the procedure call standard.
    - ``stp	x29, x30, [sp, #-16]!``
    - ``mov	x29, sp``
    - ``ldp	x29, x30, [sp], #16``
  * Identify the function call to libc that prints the string.
    - ``bl	printf`` [branch link](https://developer.arm.com/documentation/dui0379/e/arm-and-thumb-instructions/bl)
  ```
    .text
    .file	"hello_assembly.c"
    .globl	hello_assembly                  // -- Begin function hello_assembly
    .p2align	2
    .type	hello_assembly,@function
  hello_assembly:                         // @hello_assembly
    .cfi_startproc
  // %bb.0:
    stp	x29, x30, [sp, #-16]!           // 16-byte Folded Spill
    .cfi_def_cfa_offset 16
    mov	x29, sp
    .cfi_def_cfa w29, 16
    .cfi_offset w30, -8
    .cfi_offset w29, -16
    adrp	x0, .L.str
    add	x0, x0, :lo12:.L.str
    bl	printf
    .cfi_def_cfa wsp, 16
    ldp	x29, x30, [sp], #16             // 16-byte Folded Reload
    .cfi_def_cfa_offset 0
    .cfi_restore w30
    .cfi_restore w29
    ret
  .Lfunc_end0:
    .size	hello_assembly, .Lfunc_end0-hello_assembly
    .cfi_endproc
                                          // -- End function
    .type	.L.str,@object                  // @.str
    .section	.rodata.str1.1,"aMS",@progbits,1
  .L.str:
    .asciz	"Hello Assembly Language!\n"
    .size	.L.str, 26

    .ident	"clang version 19.1.7 (Fedora 19.1.7-3.fc41)"
    .section	".note.GNU-stack","",@progbits
    .addrsig
    .addrsig_sym printf
  ```

3) Write a C++ driver that calls the ``hello_assembly`` function  and test your implementation.

- ``gcc -c hello_assembly.c -o hello_assembly.o``
- ``g++ -o hello_assembly.exe hello_assembly.cpp hello_assembly.o``
- **SCREENSHOT**


Assembly Function
-----------------

1) Assemble the file and use the name ``add_values.o`` for the output.

- ``as add_values.s -o add_values.o``

2) Generate the following from ``add_values.o``:

* Hexadecimal dump
- ``od -A x -t x1 add_values.o > add_values.hex``
* Section Headers
- ``readelf -S add_values.o > add_values.relf``
* Disassembly
- ``objdump --syms -S -d add_values.o > add_values.dis``

3) Find the size of the ``.text`` section in the generated output and explain it.

```
There are 7 section headers, starting at offset 0x130:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000020  0000000000000000  AX       0     0     4
  [ 2] .data             PROGBITS         0000000000000000  00000060
       0000000000000000  0000000000000000  WA       0     0     1
  [ 3] .bss              NOBITS           0000000000000000  00000060
       0000000000000000  0000000000000000  WA       0     0     1
  [ 4] .symtab           SYMTAB           0000000000000000  00000060
       0000000000000090  0000000000000018           5     5     8
  [ 5] .strtab           STRTAB           0000000000000000  000000f0
       000000000000000f  0000000000000000           0     0     1
  [ 6] .shstrtab         STRTAB           0000000000000000  000000ff
       000000000000002c  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), p (processor specific)
```

Size of ``.text``: 0x20 byte or equal 32 byte. ``.text`` corresponds to the size of all instructions. The add_values.s file has 7 instructions in total, each is 4 byte long. Therefore $7 \cdot4$ byte $=32$ byte $=$ 0x20 byte.

4) Write a C++ driver that calls the ``add_values`` function and illustrate it with an example.

- ``g++ -o add_values.exe add_values.cpp add_values.o``
- **SCREENSHOT**

5) Use the GNU Project Debugger `GDB <https://www.sourceware.org/gdb/>`__ to step through an example call to the ``add_values`` function. Display the contents of the general-purpose registers after each of the executed instructions.

- **SCREENSHOT**
